### **햄버거 다이어트 문제 풀이 힌트**

이 문제는 주어진 칼로리 제한(`L`)을 넘지 않으면서, 맛의 점수 합이 최대가 되는 재료들의 조합을 찾는 문제입니다.

---

#### **구현 로직 힌트**

이 문제의 핵심은 **모든 가능한 재료 조합을 탐색**하는 것입니다. 재료의 개수(`N`)가 최대 20개로 비교적 작기 때문에, 모든 경우의 수를 따져보는 완전 탐색(Complete Search) 또는 깊이 우선 탐색(DFS) 방법이 효과적입니다.

* **재귀(Recursion)를 이용한 접근**: 각 재료마다 "이번 햄버거에 넣을 것인가?" 아니면 "넣지 않을 것인가?" 라는 두 가지 선택지가 있습니다. 이 선택의 과정을 모든 재료에 대해 반복하면 모든 조합을 만들어 볼 수 있습니다.

* **상태 관리**: 재귀 함수를 호출할 때는 다음 정보들을 계속해서 넘겨주어야 합니다.
    * `현재 확인 중인 재료의 인덱스`
    * `지금까지의 점수 총합`
    * `지금까지의 칼로리 총합`

* **가지치기 (Pruning)**: 탐색 중에 칼로리 총합이 제한 칼로리 `L`을 초과하면, 그 경로는 더 이상 탐색할 필요가 없습니다. 즉시 중단하고 다른 경우의 수를 탐색해야 합니다.

* **최대 점수 갱신**: 모든 재료에 대한 선택이 끝났을 때(또는 탐색 과정 중 유효한 조합이 만들어질 때마다), 만들어진 조합의 점수 총합을 이전에 기록된 최대 점수와 비교하여 더 높은 점수일 경우 갱신합니다.

---

#### **구현 순서**

1.  **입력 처리 및 초기화**:
    * `N`(재료 수), `L`(제한 칼로리)을 입력받습니다.
    * N개의 재료에 대한 `맛 점수`와 `칼로리`를 각각 배열에 저장합니다.
    * 최종 정답(가장 높은 맛 점수)을 저장할 변수(예: `maxScore`)를 0으로 초기화합니다.

2.  **재귀 함수 (DFS) 설계**:
    * `dfs(int index, int currentScore, int currentCalories)` 와 같은 형태로 함수를 만듭니다.

3.  **재귀 함수 내부 로직**:
    * **가지치기**: 함수 시작 부분에서 `currentCalories`가 `L`을 초과했는지 확인합니다. 만약 초과했다면, 이 조합은 불가능하므로 즉시 `return`하여 함수를 종료합니다.
    * **최대 점수 갱신**: 현재까지의 점수인 `currentScore`를 `maxScore`와 비교하여, `currentScore`가 더 크다면 `maxScore`를 갱신합니다. (`maxScore = Math.max(maxScore, currentScore)`)
    * **종료 조건**: `index`가 `N`과 같아지면 모든 재료를 다 확인한 것이므로 `return`하여 재귀를 종료합니다.
    * **재귀 호출**:
        1.  **현재 재료(`index`)를 포함하지 않는 경우**: 다음 재료로 넘어갑니다.
            `dfs(index + 1, currentScore, currentCalories)`
        2.  **현재 재료(`index`)를 포함하는 경우**: 점수와 칼로리를 더해서 다음 재료로 넘어갑니다.
            `dfs(index + 1, currentScore + scores[index], currentCalories + calories[index])`

4.  **실행 및 출력**:
    * 만든 재귀 함수를 `dfs(0, 0, 0)`으로 최초 호출하여 탐색을 시작합니다.
    * 모든 재귀 호출이 끝나면 `maxScore` 변수에 정답이 저장되어 있을 것입니다. 이 값을 형식에 맞게 출력합니다.