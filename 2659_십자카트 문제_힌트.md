### **십자카드 문제 풀이 힌트**

이 문제는 두 단계로 나눌 수 있습니다. 첫째, 입력받은 카드의 '시계수'를 구합니다. 둘째, 1111부터 시작해서 모든 숫자를 하나씩 확인하며, 우리가 찾은 시계수가 몇 번째 시계수인지 순서를 셉니다. 숫자의 범위가 1111부터 9999까지로 크지 않으므로, 모든 경우를 다 확인하는 **완전 탐색**이 가능합니다.

---

#### **구현 로직 힌트 (완전 탐색)**

핵심 아이디어는 **1111부터 모든 네 자리 수를 차례대로 검사하며, 그 수가 '진짜 시계수'인지 판별하는 것**입니다.

1.  **'시계수'의 정의**: 어떤 네 자리 수 `N`이 주어졌을 때,
    * `N`을 이루는 숫자들로 만들 수 있는 4개의 회전된 네 자리 수를 구합니다.
    * 만약 `N`이 그 4개의 숫자 중 가장 작다면, `N`은 '시계수'입니다.
    * **주의**: 카드에는 1~9의 숫자만 올 수 있으므로, 0이 포함된 네 자리 수는 시계수가 될 수 없습니다.

2.  **완전 탐색 로직**:
    * **1단계: 입력 카드의 시계수 찾기**
        * 먼저 입력으로 주어진 4개의 숫자로 만들 수 있는 네 자리 수 4개를 모두 구합니다. (예: `2 1 1 2` -> `2112, 1122, 1221, 2211`)
        * 이 중 가장 작은 값(`1122`)이 우리가 찾아야 할 **목표 시계수**입니다.
    * **2단계: 목표 시계수의 순서 찾기**
        * 1111부터 시작해서 우리가 찾은 **목표 시계수**까지 `for` 반복문을 실행합니다.
        * 반복문 안에서, 현재 숫자 `i`가 진짜 '시계수'인지 판별하는 함수를 호출합니다.
        * 만약 `i`가 진짜 시계수라면, 순서(rank)를 세는 카운터를 1 증가시킵니다.
        * 반복문이 끝나면, 카운터에 저장된 값이 최종 정답입니다.

---

#### **구현 순서**

1.  **목표 시계수 계산**:
    * 입력으로 4개의 숫자를 받습니다.
    * 4개의 숫자를 시계방향으로 회전시키며 만들 수 있는 네 자리 수 4개를 생성합니다.
    * `Math.min()`을 여러 번 사용하여 4개의 숫자 중 최솟값을 찾아 `target` 변수에 저장합니다.

2.  **'시계수 판별 함수' 작성**:
    * `boolean isClockNumber(int num)` 와 같은 형태로 함수를 만듭니다.
    * **내부 로직**:
        1.  `num`을 4개의 자릿수로 분해합니다. (예: `d1 = num / 1000`, `d2 = (num / 100) % 10`, ...)
        2.  분해된 숫자 중 `0`이 하나라도 있으면, 시계수가 아니므로 `false`를 반환합니다.
        3.  분해된 숫자들로 만들 수 있는 4개의 회전된 수를 모두 생성합니다.
        4.  `num`이 이 4개의 회전된 수 중 최솟값인지 비교합니다. 맞으면 `true`, 아니면 `false`를 반환합니다.

3.  **순위 계산을 위한 완전 탐색 `for`문**:
    * 순위를 저장할 변수 `count`를 0으로 초기화합니다.
    * `for (int i = 1111; i <= target; i++) { ... }` 반복문을 시작합니다.
    * **내부 로직**:
        * `if (isClockNumber(i)) { count++; }`
        * `isClockNumber` 함수를 호출하여 `i`가 진짜 시계수일 때만 `count`를 증가시킵니다.

4.  **결과 출력**:
    * 반복문이 모두 끝나면, 최종적으로 계산된 `count` 값을 출력합니다.