### **명문대 교환학생 문제 풀이 힌트**

이 문제의 목표는 **n번의 수업을 듣기 위해 필요한 최소한의 체류 일수**를 찾는 것입니다.



### **구현 로직 힌트**

가장 중요한 질문은 "언제부터 학교에 머무르기 시작해야 가장 효율적일까?" 입니다. 일주일은 7일로 고정되어 있으므로, 시작 가능한 모든 경우를 테스트해 볼 수 있습니다.

  * **최적의 시작일**: 체류 기간을 최소화하려면, **수업이 있는 날에 도착해서 바로 수업을 듣는 것**이 가장 좋습니다. 수업이 없는 날에 도착하는 것은 단순히 하루를 낭비하는 것과 같습니다.

  * **모든 시작점 테스트**: 따라서, 일주일 중 수업이 열리는 모든 요일(`a_i = 1`인 날)을 각각 시작일로 가정하고 시뮬레이션해 볼 수 있습니다.

      * 예를 들어, 월요일에 수업이 있다면 "월요일부터 체류를 시작했을 때 며칠이 걸리는지" 계산합니다.
      * 수요일에도 수업이 있다면 "수요일부터 시작했을 때 며칠이 걸리는지" 또 계산합니다.

  * **시뮬레이션**: 특정 요일부터 시작한다고 정했다면, 목표 수업 횟수 `n`을 채울 때까지 하루하루 날짜를 보내며 필요한 총일수를 계산합니다.

      * `지나온 날짜`와 `들은 수업 수`를 계속 기록합니다.
      * 하루가 지날 때마다 `지나온 날짜`는 1씩 증가합니다.
      * 그날에 수업이 있다면 `들은 수업 수`도 1 증가합니다.
      * `들은 수업 수`가 `n`이 되면 시뮬레이션을 멈추고, 그때까지 센 `지나온 날짜`를 기록합니다.

  * **최소값 찾기**: 수업이 있는 모든 요일을 시작일로 가정하여 계산한 `지나온 날짜`들 중에서 **가장 작은 값**이 바로 최종 정답이 됩니다.



-----

### **구현 순서**

아래 순서대로 코드를 작성해 보세요.

1.  **입력 받기**

      * `n`과 일주일의 수업 스케줄 배열(크기 7)을 입력받습니다.

2.  **최소 체류일 변수 선언**

      * 정답을 저장할 변수(예: `minDays`)를 선언하고, 아주 큰 값(예: `Integer.MAX_VALUE`)으로 초기화합니다. 이 변수는 시뮬레이션 결과 중 가장 작은 값을 저장하는 데 사용됩니다.

3.  **시작 요일 정하기 (외부 반복문)**

      * 일주일(0=일요일 \~ 6=토요일)을 순회하는 반복문을 만듭니다.
      * 만약 현재 요일에 수업이 없다면(`schedule[i] == 0`), 이 날은 시작일로 고려할 필요가 없으므로 건너뜁니다.

4.  **시뮬레이션 하기 (내부 반복문)**

      * 현재 요일에 수업이 있다면(`schedule[i] == 1`), 이 날을 시작점으로 시뮬레이션을 시작합니다.
      * `들은 수업 수(classCount)`, `지나온 날짜(dayCount)`, `현재 요일 인덱스(currentDayIndex)` 변수를 초기화합니다.
      * `classCount`가 `n`이 될 때까지 `while` 반복문을 실행합니다.
      * **`while`문 내부 로직**:
        1.  `dayCount`를 1 증가시킵니다.
        2.  `schedule[currentDayIndex]`가 1이면(수업이 있으면) `classCount`를 1 증가시킵니다.
        3.  `currentDayIndex`를 다음 날로 이동시킵니다. (주의: 토요일 다음은 일요일이므로 `(currentDayIndex + 1) % 7` 연산을 사용하면 편리합니다.)

5.  **최소값 갱신**

      * 하나의 시작점에 대한 `while`문 시뮬레이션이 끝나면, 계산된 `dayCount`와 이전에 저장된 `minDays`를 비교합니다.
      * `dayCount`가 더 작다면 `minDays`를 새로운 값으로 갱신합니다.

6.  **결과 출력**

      * 모든 가능한 시작 요일에 대한 탐색(외부 반복문)이 끝나면, `minDays`에 저장된 값이 최종 정답입니다. 이 값을 형식에 맞게 출력합니다.