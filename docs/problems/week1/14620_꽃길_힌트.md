### **꽃길 문제 풀이 힌트**

이 문제는 N x N 크기의 화단에 3개의 꽃을 심을 때, 꽃들이 서로 겹치거나 화단 밖으로 나가지 않으면서 비용이 최소가 되는 위치를 찾는 것입니다. 화단의 크기(N)가 최대 10으로 매우 작기 때문에, **3개의 꽃을 심을 수 있는 모든 위치 조합을 시도**해보는 완전 탐색 방법으로 해결할 수 있습니다.

---

#### **구현 로직 힌트 (조합 & 완전 탐색)**

핵심 아이디어는 **꽃의 중심(씨앗)이 될 수 있는 모든 위치 중에서 3개를 선택하는 모든 조합을 탐색**하는 것입니다.

1.  **씨앗을 심을 수 있는 유효한 위치**:
    * 꽃잎이 화단 밖으로 나가면 안 되므로, 씨앗은 화단의 가장자리에 심을 수 없습니다.
    * 즉, N x N 화단(0-based index)에서 씨앗의 위치 `(r, c)`는 `1 <= r < N-1`, `1 <= c < N-1` 범위에만 가능합니다.

2.  **3개의 씨앗 위치 조합 만들기**:
    * 씨앗을 심을 수 있는 유효한 위치들 중에서 3개를 뽑는 모든 조합을 만들어야 합니다.
    * 가장 간단한 방법은 **3중 `for`문**을 사용하는 것입니다.
        * 첫 번째 `for`문: 첫 번째 꽃의 위치를 선택합니다.
        * 두 번째 `for`문: 두 번째 꽃의 위치를 선택합니다. (단, 중복을 피하기 위해 첫 번째 꽃보다 뒤쪽 위치부터 탐색)
        * 세 번째 `for`문: 세 번째 꽃의 위치를 선택합니다. (마찬가지로 두 번째 꽃보다 뒤쪽 위치부터 탐색)

3.  **유효성 검사 (꽃잎 겹치는지 확인)**:
    * 3개의 위치가 정해지면, 이 세 꽃의 꽃잎들이 서로 겹치는지 확인해야 합니다.
    * **확인 방법 1 (거리 계산)**: 두 씨앗의 위치를 `(r1, c1)`, `(r2, c2)`라고 할 때, 두 점 사이의 맨해튼 거리 `|r1 - r2| + |c1 - c2|`가 **3 이상**이면 겹치지 않습니다. 세 쌍의 꽃((1,2), (1,3), (2,3))에 대해 모두 이 조건을 만족하는지 확인하면 됩니다.
    * **확인 방법 2 (`visited` 배열)**: `boolean[N][N]` 배열을 만들어, 첫 번째 꽃이 차지하는 5칸을 `true`로 표시합니다. 그 다음 두 번째 꽃의 5칸을 표시하려 할 때 이미 `true`인 칸을 만나면 겹치는 것이므로, 이 조합은 실패입니다. 세 번째 꽃까지 모두 성공적으로 `true` 표시를 할 수 있다면 유효한 조합입니다.

4.  **비용 계산 및 최솟값 갱신**:
    * 만약 3개의 꽃이 서로 겹치지 않는 유효한 조합이라면, 세 꽃이 차지하는 총 15칸의 비용을 모두 더합니다.
    * 이 비용을 이전에 찾았던 최소 비용(`minCost`)과 비교하여, 더 작다면 `minCost`를 새로운 값으로 갱신합니다.

---

#### **구현 순서**

1.  **입력 및 변수 초기화**:
    * 화단의 크기 `N`과 각 칸의 비용 정보를 2차원 배열에 입력받습니다.
    * 최소 비용을 저장할 변수 `minCost`를 매우 큰 값(예: `Integer.MAX_VALUE`)으로 초기화합니다.

2.  **조합 생성을 위한 3중 `for`문 작성**:
    * 씨앗을 놓을 수 있는 모든 좌표를 1차원으로 생각하고 조합을 만듭니다.
    * 예시: `for (int i = 0; i < N*N; i++) { for (int j = i + 1; j < N*N; j++) { for (int k = j + 1; k < N*N; k++) { ... } } }`
    * `i, j, k`는 1차원 인덱스이므로, `r = index / N`, `c = index % N`으로 2차원 좌표를 계산합니다.

3.  **`for`문 내부 로직**:
    * 선택된 세 좌표 `(r1, c1)`, `(r2, c2)`, `(r3, c3)`가 씨앗을 심을 수 있는 유효한 위치인지 먼저 확인합니다(가장자리가 아닌지).
    * 세 꽃이 서로 겹치지 않는지 **유효성 검사**를 수행합니다.
    * 만약 유효하지 않은 조합이라면, `continue`를 통해 다음 조합으로 넘어갑니다.
    * 유효한 조합이라면, 15칸의 총비용(`currentCost`)을 계산합니다.
    * `minCost = Math.min(minCost, currentCost);` 코드를 통해 최소 비용을 갱신합니다.

4.  **결과 출력**:
    * 모든 조합에 대한 탐색이 끝나면, `minCost`에 저장된 최종 값을 출력합니다.