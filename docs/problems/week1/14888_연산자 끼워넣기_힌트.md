# 연산자 끼워넣기 힌트파일 

## 핵심로직 힌트

- 모든 가능한 연산자 배치를 시도해 본다  
  숫자 N개 사이에는 N−1개의 연산자가 들어가야 하므로, 덧셈·뺄셈·곱셈·나눗셈의 각각 남은 개수를 관리하며 가능한 모든 순서를 탐색한다.

- 연산자 개수 관리와 백트래킹  
  연산자를 하나 선택할 때마다 남은 개수를 1 줄이고, 재귀 호출이 끝나면 다시 1 복원한다.  
  이 과정을 통해 “어떤 순서로 어떤 연산자를 썼는지”를 간편하게 추적할 수 있다.

- 왼쪽부터 차례대로 계산  
  연산 우선순위는 무시하고, 항상 “현재 계산값”에 “다음 숫자”를 바로 적용하는 식으로 진행한다.  
  예를 들어 1 + 2 × 3 이라도, “(1+2) = 3 → 3×3 = 9” 순서로 계산한다.

- 나눗셈의 특별 규칙  
  정수 나눗셈이므로 소수점 이하는 모두 버린다.  
  **음수 ÷ 양수**인 경우에는,  
  1) 먼저 절댓값 나눗셈 몫을 구하고  
  2) 그 몫에 음수 부호를 붙인다.  
  (예: –7 ÷ 3 → 7 ÷ 3 = 2 → –2)

- 최댓값·최솟값 갱신  
  모든 연산자 배치가 끝나면(재귀가 종료되면), 그때의 계산 결과를 전역에 저장된 최댓값·최솟값과 비교해 갱신한다.

---
## 구현순서

- **입력 읽기**  
  - 숫자 개수와 숫자 리스트(첫 번째 줄, 두 번째 줄)  
  - 덧셈·뺄셈·곱셈·나눗셈의 개수(세 번째 줄)  

- **초기값 설정**  
  - 첫 번째 숫자를 ‘현재 계산값’으로 삼는다  
  - 전역 최댓값은 충분히 작은 값으로, 최솟값은 충분히 큰 값으로 설정  

- **재귀 함수 구성**  
  1. 매개변수로 ‘다음 연산을 적용할 숫자의 인덱스’와 ‘지금까지 계산된 값’을 받는다  
  2. 종료 조건  
     - 인덱스가 숫자 리스트 끝을 넘어섰다면  
       → 전역 최댓값·최솟값과 비교해 갱신하고 리턴  
  3. 재귀 탐색  
     - 네 가지 연산자 중 남은 개수가 있는 것부터 하나씩 골라  
       1) 남은 개수 감소  
       2) 현재 계산값과 다음 숫자를 선택한 연산자로 결합해 새 계산값 생성  
       3) 다음 인덱스와 새 계산값으로 재귀 호출  
       4) 돌아오면 연산자 개수 복원  

- **초기 호출 및 결과 출력**  
  - 첫 번째 숫자를 기준으로 두 번째 숫자부터 재귀 호출 시작  
  - 모든 탐색 종료 후 갱신된 최댓값과 최솟값 차례대로 출력  

