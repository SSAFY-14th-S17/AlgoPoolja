### **1. 구현 로직에 대한 힌트**

이 문제는 N개의 재료에 대해 각각 **'햄버거에 넣는다'** 또는 **'넣지 않는다'**의 두 가지 선택을 하는 것과 같습니다. 이렇게 각 요소에 대한 선택지가 두 개인 상황은 **비트마스크**를 사용하기에 완벽한 조건입니다.

* **핵심 아이디어**: N개의 재료 조합을 N자리 이진수로 표현하는 것입니다.
    * N이 5라고 가정해 봅시다. `10101`이라는 5자리 이진수가 있다면, 이는 0번, 2번, 4번 재료는 **선택**하고, 1번, 3번 재료는 **선택하지 않은** 햄버거 조합을 의미합니다.
    * 즉, `i`번째 비트가 `1`이면 `i`번째 재료를 사용, `0`이면 사용하지 않음을 나타냅니다.

* **완전탐색**: 모든 가능한 햄버거 조합을 확인하려면, 모든 이진수 표현을 탐색하면 됩니다.
    * N개의 재료로 만들 수 있는 모든 조합의 수는 $2^N$개입니다.
    * 이는 0 (`00...0`) 부터 $2^N-1$ (`11...1`) 까지의 모든 숫자에 해당합니다.
    * `for` 문을 0부터 $2^N-1$까지 돌면서, 각 숫자를 하나의 '햄버거 조합(비트마스크)'으로 보고 칼로리와 맛 점수를 계산하는 것입니다.

* **조합 정보 확인**: 현재 `for`문의 숫자 `i`가 어떤 재료 조합을 의미하는지 확인해야 합니다.
    * `i`의 `j`번째 비트가 1인지 확인하려면 **`AND(&)`** 연산을 사용합니다.
    * `if ( (i & (1 << j)) != 0 )`
    * `1 << j`는 `j`번째 비트만 1인 숫자(예: `j=2`이면 `100`)를 만듭니다. 이 마스크와 `AND` 연산을 했을 때 결과가 0이 아니면, `i`의 `j`번째 비트가 1이라는 뜻입니다.

---

### **2. 구현 순서**

1.  **입력 처리**: N과 L, 그리고 N개의 재료에 대한 맛 점수와 칼로리를 각각 배열에 저장합니다. (예: `scores[]`, `calories[]`)

2.  **정답 변수 초기화**: 최종적으로 출력할 가장 높은 맛 점수를 저장할 변수 `maxScore`를 0으로 초기화합니다.

3.  **모든 조합 탐색 (바깥쪽 for문)**
    * `for (int i = 0; i < (1 << N); i++) { ... }`
    * `1 << N`은 $2^N$을 의미합니다. 이 반복문으로 0부터 모든 재료를 다 쓰는 조합까지, 모든 경우의 수를 순회합니다. 여기서 `i`가 바로 하나의 조합을 나타내는 **비트마스크**입니다.

4.  **하나의 조합에 대한 계산 (안쪽 for문)**
    * 바깥쪽 `for`문 안에서, 현재 조합(`i`)의 총점수(`currentScore`)와 총칼로리(`currentCalories`)를 계산할 변수를 0으로 초기화합니다.
    * `for (int j = 0; j < N; j++) { ... }`
    * 이 반복문으로 0번 재료부터 N-1번 재료까지 하나씩 확인합니다.

5.  **재료 포함 여부 확인**
    * 안쪽 `for`문 안에서 `if ((i & (1 << j)) != 0)` 조건을 사용해, 현재 조합 `i`에 `j`번째 재료가 포함되는지 검사합니다.
    * 포함된다면, `currentScore`에 `scores[j]`를, `currentCalories`에 `calories[j]`를 더해줍니다.

6.  **칼로리 제한 확인 및 정답 갱신**
    * 안쪽 `for`문이 끝나면, 현재 조합(`i`)의 총점수와 칼로리 계산이 완료됩니다.
    * `if (currentCalories <= L)` 조건을 확인하여 제한 칼로리를 넘지 않았는지 검사합니다.
    * 넘지 않았다면, `maxScore = Math.max(maxScore, currentScore);` 코드로 기존의 최대 점수와 현재 점수를 비교하여 더 큰 값으로 `maxScore`를 갱신합니다.

7.  **결과 출력**: 모든 조합에 대한 탐색(바깥쪽 `for`문)이 끝나면 `maxScore`에 저장된 최종 값을 형식에 맞게 출력합니다.
